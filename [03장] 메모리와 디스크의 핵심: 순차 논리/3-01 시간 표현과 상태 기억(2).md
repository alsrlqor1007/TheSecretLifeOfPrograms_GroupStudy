### 플립플롭

<br/>

데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화하기 위해 가장 일반적으로 사용되는 방법은,   
논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간에 데이터를 잡아내는 것이다.   
이 전이를 `edge`(에지)라고 부른다. 논리 수준 사이의 전이는(0에서 1, 1에서 0) 정말 순식간에 일어난다.   
`플립플롭`이란 "에지에 의해 데이터 변화가 촉발되는 래치"를 말한다.

<br/>

클록이 로우이거나 하이인 경우에는 D를 바꿔도 아무 일도 일어나지 않는다.
클록의 신호가 0에서 1로 바뀌는 시점 혹은 1에서 0으로 바뀌는 시점에 입력값(D)이 플립플롭에 저장된다.
플립플롭의 상태 변화 타이밍을 볼 때는 전파 지연외에도 `셋업 타임`과 `홀드 타임`도 고려해야 한다.   
- 셋업 타임 : 클록 에지가 발생하기 전에 신호가 얼마나 안정적으로 유지되야 하는지를 나타내는 시간
- 홀드 타임 : 클록 에지가 발생한 이후에 신호가 얼마나 안정적으로 유지되야 하는지를 나타내는 시간   

클록 에지 근처의 설정과 유지 시간을 제외한 나머지 시간에는 입력값이 무엇이든 출력값에 영향을 주지 않는다는 걸 알 수 있다.

<br/>

### 카운터

<br/>

플립플롭을 응용한 회로 중에 1,2,3 순서대로 수를 세는 카운터가 있다.
각 플립플롭의 D 입력이 자기 자신의 notQ 출력과 연결되어 있기 때문에,   
각 플립플롭은 자신의 클록 신호가 0에서 1로 전이될 때마다 상태가 바뀐다.   

각 비트의 상태가 다른 비트의 상태 변화에 약간의 `시차`를 두고 바뀌기 때문에 이 회로를 `비동기 카운터`라고 부르기도 한다.   
상태 변화가 시차를 두고 일어나기 때문에 출력값이 나오는 시점을 예측하기 어려워, 원하는대로 동작하지 않는 경우가 생긴다.   

이러한 타이밍 문제를 해결하기 위해 나온 것이 `동기적 카운터`이다.   
리플 카운터와 달리 동기적 카운터는 상태 변경이 `동시`에 일어난다.   
모든 플립플롭에 같은 클록을 병렬로 연결한다는 것을 의미한다 !!

<br/>

### 레지스터

<br/>

D 플립플롭을 사용하면 더 많은 정보를 쉽게 기억할 수 있다.   
값을 기억하기 위해 D 플립플롭을 사용하는 것은 아주 흔한 일이다.   
`레지스터`는 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것이다.   
가산기 출력을 클록을 사용해 레지스터에 넣고 나면, 가산기 입력을 바꿔도 결과는 바뀌지 않는다.

<br/>
