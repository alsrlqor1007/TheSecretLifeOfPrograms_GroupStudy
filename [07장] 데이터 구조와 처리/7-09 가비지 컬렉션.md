# 가비지 컬렉션

### 가비지 컬렉터란

<br/>

C나 C++같은 언어는 메모리의 할당과 해제를 직접, 지시하여 관리했다.   
아무리 신중하게 코드를 짜더라도 비워줘야하는 메모리 공간을 깜빡 놓쳐버리면 `메모리 누수(memory leak)`가 생긴다.   
그래서 자바를 비롯한 새로운 언어들에서는 **가비지 컬렉터** 를 도입하게 된다.

이렇게 메모리를 알아서 관리하는 언어를, managed language 라고 한다. 반대는 unmanaged language.   
프로그래머가 필요없는 메모리를 직접 해제해주지 않아도 가비지 컬렉터가 알아서 불필요한 메모리를 비우게 된다.

<br/>

### 가비지 컬렉터가 동작하는 방식

<br/>

- Mark and Sweep

  메모리를 처음부터 끝까지 훑으면서 필요한 것과 필요하지 않는 것을 마크하고, 마크되지 않는 것들은 해제시키는 방식.      
  --> 루트에 닿지 않는 변수와 함수들을 치운다고 생각하면 된다.

- Referencing Counting

  참조 카운팅. 한 요소가 다른 요소에게 몇 번 참조되는지 횟수를 세어서 그 수가 0이 되면 해제시키는 방식.      
  --> 순환 참조하게 두지 말것 !!

<p align="center">
  <img width="150" src="https://user-images.githubusercontent.com/80025242/178114345-ee0532e3-02c0-48e9-9794-b95666e5f68b.png" alt="순환 참조 예시"/>
</p>

<br/>

### 가비지 컬렉터를 사용하면 프로그래머는 메모리 관리에 무신경해도 될까

<br/>

답은 당연히 **Nope** 이다.    
프로그램의 특성에 따라 프로그래머가 직접 할당과 해제를 해주는 편이 더 맞을 수도 있다.     
즉, 프로그램의 특성이 좌우하는 것이지 항상 가비지 컬렉터가 옳은 것은 아니다.    
그리고 분명 가비지 컬렉터의 알고리즘이 놓지는, 해제되야하는 메모리를 찾지 못하는 경우도 있기 때문에, 이런 경우엔 프로그래머가 직접 해제해줘야한다.    
좋은 프로그래머는 메모리가 낭비되는 것을 막을 방법을 항상 염두에 두어야한다.
