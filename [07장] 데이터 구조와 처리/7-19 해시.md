# 해시

메모리에 데이터를 저장하고 읽는 연산 방법에 대해 이야기한다.

임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 매핑하는 단방향 함수이다. 아무리 큰 숫자를 넣어도 정해진 크기의 숫자가 나오는 함수이다.
이런 해시 함수를 적용해 나온 고정된 길이의 결과값을 해시값이라고 하며, 해시코드, 해시섬(sum), 체크섬 등으로 불린다.
<br />

### 해시 테이블, 버킷

해시테이블은 해시 함수를 이용하여 키를 해시 값으로 매핑하고, 이 해시값을 인덱스 혹은 주소로 삼아 데이터를 key와 함께 저장하는 자료구조이다.

<br />

![hashfunction](https://cdn.discordapp.com/attachments/879215554379018243/995340185007030342/unknown.png)

<br /> 단순하게 key-value로 이루어진 자료구조라고 생각하면 된다.
<br />

- **key**

  - 고유한 값으로 해시 함수의 input이다.
  - key값을 그대로 인덱스로 사요하면 key의 길이만큼 정보를 저장해야만 공간도 따로 마련해야 하기 때문에 고정된 길이의 해시로 변경한다.

- **hash function**

  - key를 고정된 길이의 hash로 변경해준다.

- **value**

  - 저장소(버킷, 슬롯)에 최종적으로 저장되는 값으로 hash와 매칭되어 저장된다.

- **bucket**
  - 데이터가 저장되는 곳이다.

<br />

**장점**

- 해시 테이블은 key-value가 1:1로 매핑되어 있어 삽입, 삭제, 검색의 과정에서 평균 O(1)의 시간 복잡도를 가진다.

**단점**

- `해시값의 범위`가 너무 크면 데이터를 너무 많이 사용하거나, 데이터가 여기저기 흩어져 메모리 접근 성능이 떨어진다.
- `해시 충돌`이 발생한다.
- 데이터가 저장되기 전 저장 공간을 미리 만들어야 하고, 공간을 미리 만들었지만 공간이 채워지지 않은 경우가 발생한다.
- hash function `의존도`가 높고, 해시 함수가 복잡하면 해시값을 만들어내는데 오래 걸린다. 해시함수는 계산하기 쉬워야 하고, 키를 골고루 버킷에 뿌려주어야한다.
  <br />

### 해시 함수의 충돌

서로 다른 key가 hashing 후 같은 hash값이 나오는 경우가 있는데 이를 해시 충돌이라고 한다. 해시 충돌 발생 확률이 적을수록 좋은 해시 함수이다. 해시 충돌이 균등하게 발생하도록 하는 것도 중요하며, 모든 키가 같은 해시 값이 나오게되면 데이터 저장 시 비효율성도 커지고, 보안이 취약해져 좋지 않다.
해시 함수 충돌을 해결하기 위해 해시 체인을 사용하기도 한다.
<br />

### 해시 체인

![hash chaining](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnMfgg%2FbtqS1WyRuWI%2F32LmJGOvrT9YTndHMvYW50%2Fimg.png)

체이닝은 저장소(버킷)에서 충돌이 발생하면 기존 값과 새로운 값을 연결리스트로 연결하는 방법이다.

- **장점**
  - 미리 충돌을 대비해서 공간을 많이 잡아놓을 필요가 없다. 출돌이 나면 그때 공간을 만들어서 연결만 해주면 된다.
- **단점**

  - 같은 hash에 자료들이 많이 연결되면 검색시 효율이 낮아진다.
  - 이를 해결하기 위해 Open Addressing(개방주소법)은 충돌이 일어나면 비어있는 hash에 데이터를 저장하는 방법이 있다. 개방주소법의 해시 테이블은 hash와 value가 1:1관계를 유지한다.
    <br />

    > 위의 그림에서 John과 Sandra의 hash가 동일해 충돌이 일어난다. 이때 Sandra는 바로 그 다음 비어있던 153 hash에 값을 저장한다. 그 다음 Ted가 테이블에 저장을 하려 했으나 본인의 hash에 이미 Sandra로 채워져 있어 Ted도 Sandra처럼 바로 다음 비어있던 154 hash에 값을 저장한다.

    이렇게 비어있는 해시 값을 찾는 방법에는 `선형 탐색`, `제곱 탐색` 등 여러 방법이 있다.

### 해시함수의 종류

**division method**

- 가장 기본적인 해시 함수.
- `숫자로 된 키 값 / 해시테이블 크기 m` 값을 해시값으로 변환한다. 간단하면서도 빠른 연산이 가능하다.
- 해시의 중복 방지를 위해 테이블의 크기 m은 소수로 사용하는것이 좋다. 하지만 남는 공간이 발생해 메모리상으로 비효율적이다.

**multiplication method**

- 숫자 키 k, A는 `0<A<1` 사이의 실수 일때 `h(k) = (ka mod 1)\*m` 으로 계산한다.
- 2진수 연산에 최적화된 컴퓨터구조를 고려한 해시함수이다.

**univeral hasing**

- 여러 개의 해시함수를 만들고, 이 `해시함수의 집합`에서 무작위로 해시함수를 선택해 해시값을 만드는 기법.
- 서로 다른 해시함수가 서로 다른 해시값을 만들어내기 때문에 같은 공간에 매핑할 확률을 줄이는 것이 목적이다.

---

<참고>
<br />
[[자료구조]해싱, 해시 테이블 그리고 Java HashMap](https://velog.io/@adam2/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94)<br />
[해시](https://namu.wiki/w/%ED%95%B4%EC%8B%9C)
