## 단일 연결 리스트(Singly Linked List)

![](https://miro.medium.com/max/953/1*elJncKhH_P9oQglfI1aVQA.png)

모든 원소가 데이터, 링크 쌍으로 이루어져 있고, 이 링크를 통해 자신의 후속 원소와 연결되는 구조를 말한다. 여러 개의 노드들이 순차적으로 연결된 형태를 갖는 자료구조이며, 첫번째 노드를 `헤드(Head)`, 마지막 노드를 `테일(Tail)`이라고 한다. 각 노드는 데이터와 다음 노드를 가리키는 `포인터(next)`로 이루어져 있다. 가장 마지막 꼬리 노드일 경우, 포인터로 이어진 노드 대신 Null을 가리키고 있다.

<br/>

- Push

```
- 함수의 인자로 새로운 노드를 생성한다.
- Head가 없다면 만들어주고 그 다음 새로운 노드가 Tail이 된다.
- Head가 있다면 Tail에 새로운 노드를 만들어주고 연결 리스트의 Tail 정보를 수정한다.
- Length를 1 증가시킨다.
```

- Pop

```
- Tail까지 리스트를 순회한다.
- 뒤에서 두 번째 노드의 다음 속성(포인터)을 null로 지정한다.
- 뒤에서 두 번째 노드를 Tail로 지정한다.
- Length를 1 차감한다.
```

- Shift

```
- 삭제 전 Head 노드 값을 변수에 할당한다.
- Head 노드 다음의 노드를 Head로 지정한다.
- Length를 1 차감한다.
```

- Unshift

```
- 함수 인자로 받은 값으로 새로운 노드를 생성한다.
- Head가 없는 경우에 Head와 Tail로 지정한다.
- 그렇지 않다면 새로 생성된 노드가 가리키는 다음 노드를 기존 Head 노드로 지정한다.
- 새로 생성된 노드를 새 Head로 지정한다.
- Length를 1 증가시킨다.
```

- Get

```
- 찾고자 하는 인덱스 번호가 0 이하거나, 또는 리스트의 길이와 같거나 더 크다면 null을 반환한다.
- 찾고자 하는 인덱스 번호까지 리스트를 순회하고 해당 인덱스 번호의 노드를 반환한다.
```

- Insert

```
- 인덱스 번호가 0보다 작거나 연결 리스트의 전체 길이보다 크다면 false를 반환한다.
- 인덱스 번호가 전체 길이와 같다면 가장 끝에 새로운 노드를 추가한다.
- 인덱스 번호가 0이라면 가장 앞에 새로운 노드를 추가한다.(Unshift)
- 위 경우에 모두 해당되지 않는다면 get 로직을 활용해 '인덱스 - 1'번째 인덱스의 노드에 접근한다.
- 새로운 노드를 접근한 노드의 다음 노드로 지정한다.
- Length를 1 증가시킨다.
```

- Remove

```
- 인덱스 값이 '전체 길이 - 1'과 같다면 pop을 수행한다.
- 인덱스 값이 0이라면 shift를 수행한다.
- 위에 모두 해당되지 않으면 get으로 '인덱스 - 1'번째의 인덱스에 접근한다.
- 해당 노드의 다음 노드를 다다음 노드로 지정한다.
- Length를 줄인다.
```

<br></br>

### 배열과의 비교

관리해야 하는 데이터의 양이 정해져 있지 않은 경우에는 배열이 적합하지 않다. 배열은 데이터 삽입이나 삭제 등의 작업을 해야 할 때, 기존 배열을 모두 복사하고 각 요소의 인덱스 번호를 매번 새로 부여한다.
반면에 연결 리스트는 원소 개수가 불분명한 경우 배열보다 더 효과적으로 데이터를 관리할 수 있다. 배열과 다르게 반드시 정해진 순서를 지키며 정렬되어 있지 않아도 된다.

|                           Lists                           |                                                  Array                                                   |
| :-------------------------------------------------------: | :------------------------------------------------------------------------------------------------------: |
|                    인덱스 번호가 없다.                    |                                  인덱스 번호와 함께 순서가 정해져 있다.                                  |
|     다음 노드를 가리키는 포인터로 서로 연결되어 있다.     | 요소의 삽입과 삭제에 비용이 든다. 오래 걸린다. 배열 중간에 있는 데이터가 삭제되면, 공간 낭비가 발생한다. |
| 임의로 요소 접근이 안된다. 처음부터 탐색을 진행해야 한다. |                  인덱스를 통한 빠른 접근이 가능하다. 특정 인덱스로 바로 접근할 수 있다.                  |

<br></br>

### 이중 간접 주소 지정을 사용한 코드

<div align="center">

![](https://images.velog.io/images/ne_ol/post/eb956a90-b4e8-4ae7-b3f2-5f8b0df9d978/Screen%20Shot%202022-02-15%20at%202.49.26%20AM.png)

</div>

```
1. current0을 head 주소로 설정
2. current1은 head를, head는 리스트 원소 A의 노드를 가리킴
3. 삭제할 원소가 D가 아니기 때문에 다음 동일하게 진행. current2는 current(=A)의 next값을 가리킴
4. 삭제할 노드가 나올 때까지 반복
5. D를 찾았을 때, C.next를 D.next값으로 할당
```

<br></br>
